正则表达式基本语法
---
1. 界定符
2. 原子
3. 量词
4. 边界控制
5. 模式单元

界定符
---
表示一个正则表达式的开始和结束

可以使用的界定符：'/[0-9]/'，'#[0-9]#'，'{[0-9]}'(习惯上不适用{})

正则表达式工具
---
###regexpal
书写正则的时候，不需要使用界定符

原子
---
###可见原子
Unicode编码表中用键盘输出后肉眼可见的字符

有哪些？
* 标点; " _ ? . 等等
* 英文大小写字母和数字 a-z,A-Z,0-9
* 汉字、日文、阿拉伯文等其他语言文字
* ∑,∮,∈,≌等数理化公式符号
* 其他可见字符

###不可见原子
Unicode编码表中用键盘输出后肉眼不可见的字符

有哪些？
* 换行符 \n
* 回车 \r
* 制表符 \t
* 空格
* 其它不可见符号

匹配汉字时，可能会遇到由编码格式引发的错误

**站长之家**有可用的汉字转Unicode编码工具，可以直接将汉字转为Unicode

一些需要转移的符号：\，$，!，(，+，*，.，^等等，使用时需要加一个'\'来转义

元字符
---
###原子的集合
|元字符 |描述 |
|:---:|:---|
|. |匹配除换行符之外的任意字符 |
|\d |匹配任意一个十进制数字，即[0-9] |
|\D |匹配任意一个非十进制数字，即[^0-9] |
|\s |匹配一个不可见原子，即[\f\n\r\t\v] |
|\S |匹配一个可见原子，即[^\f\n\r\t\v] |
|\w |匹配任意一个数字、字母或下划线，即[0-9a-zA-Z_] |
|\W |匹配任意一个非数字、字母或下划线，即[^0-9a-zA-Z_] |
|\b |匹配单词的开始或结束 |

###原子的筛选方式
|筛选方式 |描述 |
|:---: |:--- |
|丨 |匹配两个或者多个分支选择 |
|[] |匹配方括号中的任意一个原子 |
|\[^\] |匹配除方括号中的原子之外的任意字符 |

###示例练习
* 匹配'Duang~'和'duang~'

    `/Duang~|duang~/` 或者 `/[Dd]uange~/`

* 匹配用尖括号括起来的以'a'开头的字符串，如'<ab>','<a34>'

    `/<a[^>]+>/` '[^>]'为非'>'的字符

量词
---
|量词 |描述 |
|:---: |:--- |
|{n} |表示其前面的原子恰好出现n次 |
|{n,} |表示其前面的原子最少出现n次 |
|{n,m} |表示其前面的原子最少出现n次,最多出现m次 |
|* |匹配任意次数的其之前的原子，即{0,} |
|+ |匹配1次或者多次其之前的原子，即{1,} |
|? |匹配0次或者1次其之前的原子，即{0,1} |

###示例
* 匹配'aaa'

    `/aaa/` 或者`/a{3}/`

* 匹配任意3个连续的英文字母

    `/[a-zA-Z]{3}/`

* 匹配连续出现至少4次英文字母或数字或下划线的情况

    `/[a-zA-Z0-9_]{4,}/` 或者 `/\w{4,}/`

* 匹配'https或http'

    `/https|http/` 或者 `/https?/`

边界控制
---
|边界控制 |描述 |
|:---: |:--- |
|^ |匹配字符串开始的位置 |
|$ |匹配字符串结尾的位置 |
|() |匹配其中的整体为一个原子 |

分组(子表达式)
---
重复多个字符该怎么办呢？这时可以使用小括号来指定子表达式，这样你就可以指定这个子表达式重复的次数了。

###使用示例
* 匹配'Duang~'或者'duang~'

    `/(D|d)uang~/`

* 匹配任意1-3个数字后面加一个'.'3次

    `/(\d{1,3}\.){3}/`

* 匹配正确的ipv4地址

    ```
    /((2[0-4]\d|25[0-5]|[01]?\d{1,2})\.){3}(2[0-4]\d|25[0-5]|[01]?\d{1,2})/

    // ============================================
    // 解释：
    // 2[0-4]\d 能够匹配的数的范围是200-249
    // 25[0-5] 能够匹配的数的范围是250-255
    // [01]?\d{1,2} 能够匹配的数的范围是0-199，但是有几种格式0，00，01，010.前面带前导0在ip地址中是被允许的
    // 所以整个(2[0-4]\d|25[0-5]|[01]?\d{1,2})匹配的是0-255
    ```

修正模式
---
模式修正符号在正则表达式定界符之外使用(最后一个斜线'/'之后)，例如'/php/i'。其中'/php/'是一个正则表达式的模式，而'i'就是修正此模式所使用的修正符号，用来匹配时不区分大小写。

模式修正符可以调整正则表达式的解释，扩展了正则表达式在匹配、替换等操作时的某些功能，而且模式修正符号也可以组合使用，更增强了正则表达式的处理能力。例如：'/php/Uis'，3个模式修正符一起使用。

模式修正符对编写简短洁净的表达式大有帮助。

|匹配模式 |描述 |
|:---: |:--- |
|U |使量词默认为非贪婪的，通过量词后紧跟？的方式可以使其成为贪婪的。 |
|i |忽略英文字母大小写 |
|x |忽略空白 |
|s |让与字符'.'匹配包括换行符在内的所有字符 |
|m |将字符串视为多行。默认的正则表达式开始'^'和结束'$'将目标字符串作为单一的一"行"字符(尽管里面很可能有换行符)。如果在修饰符中加上'm'，那么开始和结束将会指字符串的每一行，每一行的开头就是'^'，结尾就是'$' |

###贪婪匹配与懒惰匹配
* 贪婪匹配 - 匹配结果存在歧义时取其长(默认)
* 懒惰匹配 - 匹配结果存在歧义时取其短

```php
<?php
    // 定义一个打印输出函数
    function p($msg) {
        echo '<pre style="color:red;">';
        print_r($msg);
    }

    $pattern = '/myFriends.+0/'; // 要匹配的正则模式
    $subject = 'myFriends__00000000'; // 需要查找的文本
    $matches = [];
    preg_match($pattern, $subject, $matches);
    p($matches); // 默认使用贪婪模式，匹配结果为 myFriends__00000000

    // 使用贪婪模式匹配
    $pattern = '/myFriends.+0/U'; // 这是.+将进行最少匹配
    preg_match($pattern, $subject, $matches);
    p($matches); // 匹配结果是 myFriends__0
?>
```

###忽略英文字母的大小写匹配

```php
<?php
    $pattern = '/myfriends.+0/';
    $subject = 'myFriends__00000000';
    $matches = [];
    preg_match($pattern, $subject, $matches);
    p($matches); // 不能匹配到任何内容

    $pattern = '/myfriends.+0/Ui'; // 忽略大小写进行非贪婪匹配
    preg_match($pattern, $subject, $matches);
    p($matches); // myFriends__0
?>
```

###忽略空白字符

```php
<?php
    $pattern = '/my friend  s.+0/Uix';
    $subject = 'myFriends__00000000'
    $matches = [];
    preg_match($pattern, $subject, $matches);
    p($matches); // myFriends__0
?>
```

反向引用
---
使用小括号指定了一个子表达式后，匹配的这个子表达式的内容需要做一些其它进一步的处理，如重复搜索前面某子表达式匹配的内容。

默认情况下，每个子表达式(分组)自动拥有一个组号，规则是：从左往右，以分组的左括号为标志，第一个出现的组号为1，第二个为2，一次类推。`\b(\w+)\b\s+\1\b`可以匹配重复的单词，如'go go'， 'everyone everyone'。

也可以自己指定子表达式的**组名**。指定子表达式组名的语法：`(?<Word>\w+)` 或者 `(?'Word'\w+)` - 指定`\w+`子表达式的组名为'Word'，反向引用这个捕获的内容使用`\k<Word>`，所以上一个例子可以写成：`\b(?<Word>\w+)\b\s+\k<Word>\b`

|捕获语法 |说明 |
|:---: |:--- |
|`(exp)` |匹配exp，并捕获文本到自动命名的组里 |
|`(?<name>exp)` |匹配exp，并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
|`(?:exp)` |匹配exp，不捕获匹配的文本，也不给此分组分配组号 |

断言
---
|零宽断言语法 |说明 |
|:---:|:---|
|`(?=exp)` |匹配exp前面的位置 |
|`(?<=exp)` |匹配exp后面的位置 |
|`(?!exp)` |匹配后面跟的不是exp的位置 |
|`(?<!exp)` |匹配前面不是exp的位置 |

###零宽断言
上面的四个表达式用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说他们像\b，^，$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被成为**零宽断言**。

`(?=exp)`，也叫作**零宽度预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配_以ing结尾的单词的前面部分(除了ing以外的部分)_，如查找"I'm singing while you're dancing."时，它会匹配sing和danc。

`(?<=exp)`，也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配_以re开头的单词的后半部分(除了re以外的部分)_，如查找"reading a book"时，它匹配ading。

假如你想要给一个很长的数字中每三位间加一个逗号(当然就从右边加起来)，你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，

使用两种断言：`(?<=\s)\d+(?=\s)`匹配_以空白符间隔的数字(不包括两端的空白符)_

###负向零宽断言
前面我们提到过查找 不是某个字符或不在某个字符类里的字符。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？如：我们想查找这样的单词--它里面出现了字母q，但是q后面跟的不是字母u的单词。`\b\w*q[^u]\w*\b`匹配包含q字母且q后面不是u的单词。但是像'Iraq,Benq'这样的字符也能够被匹配。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。`\b\w*q(?!u)\w*\b`

零宽度负预测先行断言`(?!exp)`，断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词

还可以使用`(?<!exp)` - 零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

`(?<=<(\w+)>).*(?=<\/\1>)` 匹配不包含属性的简单HTML标签内里的内容。

注释
---
小括号的另一种用途是通过语法`(?#comment)`来包含注释。如`2[04]\d(?#200-249)|25[0-5](?#250-255)|[01]\d{1,2}(?#0-199)`。

要包含注释的花最好启用"忽略模式里的空白符"选项，这样在编写表达式的时候能任意添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。如：

```
(?<=        # 断言要匹配的文本的前缀
<(\w+)>     # 查找尖括号括起来的字母或数字(HTML/XML标签)
)           # 前缀结束
.*          # 匹配任意文本
(?=         # 断言要匹配的文本的后缀
<\/\1>      # 查找尖括号括起的内容：前面是一个'/'，后面是先前捕获的标签
)           # 后缀结束
```

贪婪与懒惰
---
当正则表达式中包含能接受重复的限定符时，通常的行为是(在使整个表达式能得到匹配的前提下)匹配尽可能多的字符。以这个表达式为例`a.*b`，它将会匹配_最长的以a开始，以b结束的字符串_。

时常我们更需要的是懒惰匹配，也就是尽可能少的字符前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样`.*?`就意味着_匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复_。 `a.*?b`用来匹配'aabab'的话，它将会匹配'aab(第1-3个字符)'和'ab(第4-5个字符)'。

为什么第一个匹配的是'aab(第1-3个字符)'，而不是'ab(第2-3个字符)'？简单地说，这是因为正则表达式有另一条规则，它比贪婪与懒惰这条规则的优先级更高 - 最先开始的匹配拥有最高的优先权。

|懒惰限定符语法 |描述 |
|:---: |:--- |
|*? |重复任意次，但尽可能少重复 |
|+? |重复1次或更多次，但尽可能少重复 |
|?? |重复0次或1次，但尽可能少重复 |
|{n,m}? |重复n次到m次，但尽可能少重复 |
|{n,}? |重复至少n次，但尽可能少重复 |

平衡组/递归匹配
---
有时我们需要匹配像'(100*(50+15))'这样的可嵌套的层次性结构，这时简单地使用`\(.+\)`则只会匹配到最左边的左括号和最右边的右括号之间的内容(贪婪模式下)。但是如果是这样的字符串'(5/(3+2)))'，左括号与右括号不等，但我们想匹配的左括号与右括号一样多的最长内容，该怎么办呢？

这里需要使用到以下语法：
* `(?'group')` 把捕获的内容命名为group，并压入堆栈(stack)
* `(?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
* `(?(group)yes|no)` 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
* `(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

我们需要做的是每碰到了左括号，就在压入一个'Open'，每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空--如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。

```
<                   # 最外层的左括号
    [^<>]*          # 最外层的左括号后面的不是括号的内容
    (
        (
            (?'Open'<)  # 碰到了左括号，在黑板上写一个'Open'
            [^<>]*      # 匹配左括号后面的不是括号的内容
        )+
        (
            (?'-Open'>) # 碰到了右括号，就擦掉一个'Open'
            [^<>]*      # 匹配右括号后面不是括号的内容
        )+
    )*
    (?(Open)(?!))   # 在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的'Open'；如果还有，则匹配失败
>                   # 最外层的右括号
```

参考文章
---
1. [《正则表达式30分钟入门教程》](http://deerchao.net/tutorials/regex/regex.htm) - **deerchao** _2013-01-10_
2. [慕课网 - 《鬼斧神工之正则表达式》](http://imooc.com/learn.350) - **badguy**
3. [《PHP中文文档》](http://php.net/manual/zh/book.pcre.php)





























